----- filename : deployment.yaml -----
apiVersion: apps/v1  # Kubernetes API version for Deployments (stable version)
kind: Deployment  # Type of resource - manages a set of identical pods
metadata:  # Information about this Deployment
  name: health-service  # Name of the Deployment (used in kubectl commands) → MUST MATCH hpa.yaml line 11
  # namespace: default  # Optional: Namespace (defaults to 'default')
  labels:  # Key-value pairs for organizing/selecting resources
    app: health-service  # Label to identify this as part of health-service app (not used for matching, just organization)
    # version: v1  # Optional: version label for canary/blue-green deployments
  # annotations:  # Optional: Non-identifying metadata
  #   description: "Health monitoring service"
  #   owner: "platform-team"
spec:  # Desired state specification
  replicas: 5  # Number of pod copies to run (change this to scale manually)
  # revisionHistoryLimit: 10  # Optional: Number of old ReplicaSets to keep (default: 10)
  # progressDeadlineSeconds: 600  # Optional: Max time for deployment to progress (default: 600s)
  # minReadySeconds: 0  # Optional: Min time pod must be ready before considered available
  # strategy:  # Optional: How to replace old pods with new ones
  #   type: RollingUpdate  # RollingUpdate (default) or Recreate
  #   rollingUpdate:
  #     maxUnavailable: 1  # Max pods unavailable during update (number or %)
  #     maxSurge: 1  # Max extra pods during update (number or %)
  selector:  # How this Deployment finds which pods it manages
    matchLabels:  # Pods with these labels are managed by this Deployment
      app: health-service  # → MUST MATCH template.metadata.labels.app below (line 28)
  template:  # Blueprint for creating pods
    metadata:  # Metadata for each pod created
      labels:  # Labels applied to each pod (must match selector above)
        app: health-service  # → MUST MATCH selector.matchLabels.app above (line 24) AND service-clusterip.yaml selector (line 23)
      # annotations:  # Optional: Pod annotations
      #   prometheus.io/scrape: "true"  # Example: enable Prometheus scraping
      #   prometheus.io/port: "8080"
    spec:  # Pod specification - what runs inside each pod
      # serviceAccountName: default  # Optional: ServiceAccount for pod (default: "default")
      # imagePullSecrets:  # Optional: Secrets for pulling from private registries
      # - name: ecr-secret  # Reference to Secret containing registry credentials
      # nodeSelector:  # Optional: Schedule pods only on nodes with these labels
      #   disktype: ssd  # Example: only nodes with SSD storage
      #   zone: us-east-1a
      # tolerations:  # Optional: Allow pods on nodes with matching taints
      # - key: "dedicated"
      #   operator: "Equal"
      #   value: "compute"
      #   effect: "NoSchedule"
      # affinity:  # Optional: Advanced pod scheduling rules
      #   nodeAffinity:  # Where pods prefer/require to be scheduled
      #     requiredDuringSchedulingIgnoredDuringExecution:
      #       nodeSelectorTerms:
      #       - matchExpressions:
      #         - key: kubernetes.io/arch
      #           operator: In
      #           values: [amd64, arm64]
      #   podAntiAffinity:  # Don't schedule pods on same node
      #     preferredDuringSchedulingIgnoredDuringExecution:
      #     - weight: 100
      #       podAffinityTerm:
      #         labelSelector:
      #           matchExpressions:
      #           - key: app
      #             operator: In
      #             values: [health-service]
      #         topologyKey: kubernetes.io/hostname
      # restartPolicy: Always  # Optional: Always (default), OnFailure, Never
      # terminationGracePeriodSeconds: 30  # Optional: Time to wait before killing pod (default: 30)
      # dnsPolicy: ClusterFirst  # Optional: ClusterFirst (default), Default, None
      containers:  # List of containers in the pod (usually just one)
      - name: health-service  # Container name (shown in logs)
        image: health-service:local  # Docker image to use (change to ECR URL for EKS)
        imagePullPolicy: Never  # Don't pull from registry, use local image (change to "Always" for ECR)
        # args:  # Optional: Override container CMD
        # - "--port=8080"
        # - "--log-level=info"
        # command:  # Optional: Override container ENTRYPOINT
        # - /app/server
        # env:  # Optional: Environment variables
        # - name: LOG_LEVEL  # Simple key-value
        #   value: "info"
        # - name: DATABASE_URL  # From Secret
        #   valueFrom:
        #     secretKeyRef:
        #       name: db-secret
        #       key: url
        # - name: POD_NAME  # From pod metadata
        #   valueFrom:
        #     fieldRef:
        #       fieldPath: metadata.name
        # envFrom:  # Optional: Load all keys from ConfigMap/Secret as env vars
        # - configMapRef:
        #     name: app-config
        # - secretRef:
        #     name: app-secrets
        ports:  # Which ports the container exposes
        - containerPort: 8080  # Port your app listens on inside the container → MUST MATCH service-clusterip.yaml targetPort (line 26)
          # name: http  # Optional: Name for this port (not used for matching)
          # protocol: TCP  # Optional: TCP (default) or UDP
        resources:  # Resource limits and requests for scheduling
          requests:  # Minimum resources needed (used for scheduling decisions)
            memory: "256Mi"  # Minimum RAM guaranteed (change based on app needs)
            cpu: "500m"  # Minimum CPU guaranteed (500m = 0.5 CPU cores)
          limits:  # Maximum resources allowed (prevents runaway usage)
            memory: "512Mi"  # Max RAM before pod gets OOMKilled (change to prevent crashes)
            cpu: "1000m"  # Max CPU (1000m = 1 full CPU core)
        # livenessProbe:  # Optional: Check if container is alive (restart if fails)
        #   httpGet:  # HTTP health check
        #     path: /health  # Endpoint to check
        #     port: 8080
        #     # httpHeaders:  # Optional: custom headers
        #     # - name: Custom-Header
        #     #   value: value
        #   initialDelaySeconds: 30  # Wait before first check (let app start)
        #   periodSeconds: 10  # Check every 10 seconds
        #   timeoutSeconds: 5  # Request timeout
        #   successThreshold: 1  # Min consecutive successes (must be 1 for liveness)
        #   failureThreshold: 3  # Failures before restart
        #   # Alternative: TCP check
        #   # tcpSocket:
        #   #   port: 8080
        #   # Alternative: Execute command
        #   # exec:
        #   #   command:
        #   #   - cat
        #   #   - /tmp/healthy
        # readinessProbe:  # Optional: Check if container ready for traffic (remove from service if fails)
        #   httpGet:
        #     path: /health
        #     port: 8080
        #   initialDelaySeconds: 5  # Can be shorter than liveness
        #   periodSeconds: 5  # Check more frequently
        #   timeoutSeconds: 3
        #   successThreshold: 1  # Successes before marking ready
        #   failureThreshold: 3  # Failures before removing from service
        # startupProbe:  # Optional: Check if app has started (disables liveness until passes)
        #   httpGet:
        #     path: /health
        #     port: 8080
        #   initialDelaySeconds: 0
        #   periodSeconds: 10
        #   timeoutSeconds: 3
        #   successThreshold: 1
        #   failureThreshold: 30  # Allow 5 minutes to start (30 * 10s)
        # lifecycle:  # Optional: Hooks for container lifecycle events
        #   postStart:  # Run immediately after container starts
        #     exec:
        #       command: ["/bin/sh", "-c", "echo Hello from postStart > /tmp/poststart"]
        #   preStop:  # Run before container terminates (graceful shutdown)
        #     exec:
        #       command: ["/bin/sh", "-c", "sleep 15"]  # Wait for connections to drain
        # securityContext:  # Optional: Security settings for this container
        #   runAsUser: 1000  # Run as specific user ID
        #   runAsGroup: 3000  # Run as specific group ID
        #   runAsNonRoot: true  # Require non-root user
        #   readOnlyRootFilesystem: true  # Make root filesystem read-only
        #   allowPrivilegeEscalation: false  # Don't allow gaining more privileges
        #   capabilities:  # Linux capabilities
        #     drop:
        #     - ALL  # Drop all capabilities
        #     add:
        #     - NET_BIND_SERVICE  # Add back specific capabilities
        # stdin: false  # Optional: Allocate stdin (default: false)
        # tty: false  # Optional: Allocate TTY (default: false)
        # workingDir: /app  # Optional: Working directory inside container
        volumeMounts:  # Mount volumes into the container
        - name: docker-sock  # Name of volume to mount (matches volumes below)
          mountPath: /var/run/docker.sock  # Where to mount inside container
      volumes:  # Volumes available to containers in this pod
      - name: docker-sock  # Volume name (referenced in volumeMounts)
        hostPath:  # Mount a path from the node's filesystem
          path: /var/run/docker.sock  # Docker socket on host (usually not needed in production)
          # type: File  # Optional: File, Directory, Socket, etc.
      # Optional volume types:
      # - name: config-volume  # ConfigMap volume
      #   configMap:
      #     name: app-config  # ConfigMap name
      #     # items:  # Optional: select specific keys
      #     # - key: app.conf
      #     #   path: config/app.conf
      # - name: secret-volume  # Secret volume
      #   secret:
      #     secretName: app-secrets
      #     # defaultMode: 0400  # File permissions
      # - name: empty-dir  # Temporary storage (deleted with pod)
      #   emptyDir: {}
      #     # medium: Memory  # Use RAM instead of disk
      #     # sizeLimit: 1Gi  # Max size
      # - name: pvc-storage  # Persistent storage
      #   persistentVolumeClaim:
      #     claimName: my-pvc  # PersistentVolumeClaim name
      # - name: nfs-volume  # NFS mount
      #   nfs:
      #     server: nfs-server.example.com
      #     path: /exported/path
      # - name: aws-ebs  # AWS EBS volume
      #   awsElasticBlockStore:
      #     volumeID: vol-1234567890abcdef0
      #     fsType: ext4



----- filename : hpa.yaml -----
apiVersion: autoscaling/v2  # Kubernetes API version for HPA (v2 supports multiple metrics)
kind: HorizontalPodAutoscaler  # Type of resource - automatically scales pod replicas

metadata:  # Information about this HPA
  name: health-service-hpa  # Name of this HPA (used in kubectl commands)
  # namespace: default  # Optional: namespace (defaults to 'default')

spec:  # HPA specification
  scaleTargetRef:  # What resource this HPA scales
    apiVersion: apps/v1  # API version of the target resource
    kind: Deployment  # Type of resource to scale (Deployment, ReplicaSet, StatefulSet)
    name: health-service  # Name of the Deployment → MUST MATCH deployment.yaml metadata.name (line 4)

  minReplicas: 2  # Minimum number of pods (never scale below this)
  maxReplicas: 10  # Maximum number of pods (never scale above this)

  metrics:  # List of metrics used to determine scaling decisions
  - type: Resource  # Metric type: Resource (CPU/memory), Pods (custom), Object (external), External, ContainerResource
    resource:  # Resource-based metrics (requires metrics-server)
      name: cpu  # Resource name: cpu or memory
      target:  # Target threshold for this metric
        type: Utilization  # Target type: Utilization (percentage) or AverageValue (raw value like "100m")
        averageUtilization: 70  # Scale up when average CPU across all pods > 70%
        # averageValue: "500m"  # Alternative: scale based on absolute CPU (500 millicores)

  # Optional: Add memory-based scaling
  # - type: Resource
  #   resource:
  #     name: memory
  #     target:
  #       type: Utilization
  #       averageUtilization: 80  # Scale when memory > 80%

  # Optional: Scale based on custom metrics (requires custom metrics API)
  # - type: Pods
  #   pods:
  #     metric:
  #       name: http_requests_per_second  # Custom metric name
  #     target:
  #       type: AverageValue
  #       averageValue: "1000"  # Scale when requests/sec > 1000

  # Optional: Scale based on external metrics (like queue length)
  # - type: External
  #   external:
  #     metric:
  #       name: sqs_queue_messages_visible
  #       selector:
  #         matchLabels:
  #           queue_name: my-queue
  #     target:
  #       type: Value
  #       value: "30"  # Scale when queue has > 30 messages

  behavior:  # Optional: fine-tune scaling behavior (omit for default behavior)
    scaleUp:  # How fast to scale up when needed
      stabilizationWindowSeconds: 0  # Wait time before scaling up (0 = immediate, prevents flapping)
      policies:  # List of scale-up policies (can have multiple)
      - type: Percent  # Policy type: Percent (% increase) or Pods (absolute number)
        value: 100  # Double the number of pods (100% increase)
        periodSeconds: 15  # Apply this policy every 15 seconds
      - type: Pods  # Alternative: absolute pod increase
        value: 4  # Add 4 pods at a time
        periodSeconds: 15  # Every 15 seconds
      selectPolicy: Max  # Which policy to use: Max (most aggressive), Min (most conservative), Disabled
      # selectPolicy: Min  # Use the policy that adds fewest pods

    scaleDown:  # How fast to scale down when load decreases
      stabilizationWindowSeconds: 30  # Wait 30s before scaling down (prevents flapping)
      policies:  # Scale-down policies
      - type: Percent  # Reduce by percentage
        value: 50  # Remove 50% of pods at a time
        periodSeconds: 15  # Every 15 seconds
      # - type: Pods  # Alternative: absolute reduction
      #   value: 2  # Remove 2 pods at a time
      #   periodSeconds: 60  # Every minute
      # selectPolicy: Min  # Optional: use most conservative policy (default: Min for scale down)

  # Optional: Control how often HPA checks metrics
  # Default is 15 seconds, controlled by kube-controller-manager flags
  # Cannot be set per-HPA in v2

# Common configurations for different use cases:

# 1. Conservative scaling (slow and steady):
#   scaleUp: stabilizationWindowSeconds: 60, Percent: 50%
#   scaleDown: stabilizationWindowSeconds: 300, Percent: 10%

# 2. Aggressive scaling (fast response):
#   scaleUp: stabilizationWindowSeconds: 0, Pods: 10
#   scaleDown: stabilizationWindowSeconds: 60, Percent: 50%

# 3. Memory-based scaling:
#   Add memory metric with averageUtilization: 80

# 4. Multiple metrics (scales if ANY metric threshold is exceeded):
#   Add both CPU and memory metrics


----- filename : ingress-controller.yaml -----
# ============================================================================
# NGINX INGRESS CONTROLLER
# ============================================================================
#
# ⚠️  NON-STANDARD KUBERNETES RESOURCE (ADDON/INFRASTRUCTURE)
#
# This file is DIFFERENT from the other Kubernetes resources (deployment.yaml,
# service.yaml, ingress.yaml, hpa.yaml) because:
#
# 1. ADDON vs CORE RESOURCE:
#    - Core K8s resources (Deployment, Service, Ingress, HPA) are built into
#      Kubernetes - you create them with kubectl apply
#    - Ingress Controller is an ADDON - software you install separately that
#      actually implements the Ingress routing logic
#
# 2. WHY IS IT NEEDED?
#    - Kubernetes Ingress resources (like ingress.yaml) are just RULES
#    - They describe "route traffic from / to service X on port 80"
#    - But Ingress resources don't DO anything by themselves
#    - You need an Ingress Controller to READ those rules and route traffic
#
# 3. THE RELATIONSHIP:
#    - Ingress Controller (this file) = The traffic router software (NGINX)
#    - ingress.yaml = Configuration file telling the controller where to route
#
#    Analogy:
#    - Ingress Controller = Web server (like NGINX or Apache)
#    - ingress.yaml = The config file (/etc/nginx/nginx.conf)
#
# 4. WHY MULTIPLE OPTIONS?
#    Kubernetes doesn't mandate one ingress controller. You choose:
#    - NGINX Ingress Controller (this file) - most popular
#    - Traefik - feature-rich, built-in Let's Encrypt
#    - AWS ALB Ingress Controller - integrates with AWS Application Load Balancer
#    - HAProxy, Istio, Envoy, etc.
#
#    Your ingress.yaml specifies which one to use:
#      spec:
#        ingressClassName: nginx  # ← Uses NGINX controller
#
# 5. PRODUCTION DEPLOYMENT:
#    In production, you'd typically install this via Helm:
#      helm install nginx-ingress ingress-nginx/ingress-nginx \
#        --set controller.service.type=LoadBalancer \
#        --set controller.autoscaling.enabled=true
#
#    This file is the raw YAML equivalent for learning/local development.
#
# 6. WHAT THIS FILE CONTAINS:
#    - Namespace: Isolated namespace for ingress controller
#    - ServiceAccounts: Identity for the controller pods
#    - Roles/ClusterRoles: Permissions to read Ingress resources
#    - RoleBindings: Link roles to service accounts
#    - ConfigMap: NGINX configuration (allow-snippet-annotations, etc.)
#    - Services: Expose NGINX on ports 80/443
#    - Deployment: The actual NGINX controller pods
#    - Jobs: Webhook certificate generation (validates Ingress resources)
#    - IngressClass: Defines the "nginx" class that ingress.yaml references
#    - ValidatingWebhookConfiguration: Validates Ingress YAML before creation
#
# ============================================================================

apiVersion: v1  # Kubernetes API version for Namespaces
kind: Namespace  # Create isolated namespace for ingress controller
metadata:
  labels:
    app.kubernetes.io/instance: ingress-nginx  # Instance identifier
    app.kubernetes.io/name: ingress-nginx  # Application name
  name: ingress-nginx  # Namespace name (all controller resources go here)
---
# ============================================================================
# SERVICE ACCOUNTS - Identity for pods to authenticate with Kubernetes API
# ============================================================================
apiVersion: v1
automountServiceAccountToken: true  # Automatically mount API token in pods
kind: ServiceAccount  # Identity used by controller pods
metadata:
  labels:
    app.kubernetes.io/component: controller  # This is for the main controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx  # ServiceAccount name (used in Deployment spec)
  namespace: ingress-nginx
---
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-admission
  namespace: ingress-nginx
---
# ============================================================================
# RBAC - Permissions for the ingress controller to function
# ============================================================================
# Role: Permissions within the ingress-nginx namespace only
# ClusterRole: Cluster-wide permissions (read Ingress resources across all namespaces)
# RoleBinding/ClusterRoleBinding: Link ServiceAccounts to Roles
#
# Why needed: Controller needs to:
# - Read Ingress resources to know routing rules
# - Read Services/Endpoints to know where to route traffic
# - Read Secrets for TLS certificates
# - Update Ingress status fields
# - Create/update ConfigMaps for dynamic configuration
# ============================================================================
apiVersion: rbac.authorization.k8s.io/v1
kind: Role  # Namespace-scoped permissions (within ingress-nginx namespace)
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx
  namespace: ingress-nginx
rules:  # List of permissions
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
- apiGroups:
  - ""
  resources:
  - configmaps
  - pods
  - secrets
  - endpoints
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - networking.k8s.io
  resources:
  - ingresses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - networking.k8s.io
  resources:
  - ingresses/status
  verbs:
  - update
- apiGroups:
  - networking.k8s.io
  resources:
  - ingressclasses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - coordination.k8s.io
  resourceNames:
  - ingress-nginx-leader
  resources:
  - leases
  verbs:
  - get
  - update
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - create
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
- apiGroups:
  - discovery.k8s.io
  resources:
  - endpointslices
  verbs:
  - list
  - watch
  - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-admission
  namespace: ingress-nginx
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - get
  - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx
rules:
- apiGroups:
  - ""
  resources:
  - configmaps
  - endpoints
  - nodes
  - pods
  - secrets
  - namespaces
  verbs:
  - list
  - watch
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - get
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - networking.k8s.io
  resources:
  - ingresses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
- apiGroups:
  - networking.k8s.io
  resources:
  - ingresses/status
  verbs:
  - update
- apiGroups:
  - networking.k8s.io
  resources:
  - ingressclasses
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - discovery.k8s.io
  resources:
  - endpointslices
  verbs:
  - list
  - watch
  - get
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-admission
rules:
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - validatingwebhookconfigurations
  verbs:
  - get
  - update
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx
  namespace: ingress-nginx
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ingress-nginx
subjects:
- kind: ServiceAccount
  name: ingress-nginx
  namespace: ingress-nginx
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-admission
  namespace: ingress-nginx
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: ingress-nginx-admission
subjects:
- kind: ServiceAccount
  name: ingress-nginx-admission
  namespace: ingress-nginx
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: ingress-nginx
subjects:
- kind: ServiceAccount
  name: ingress-nginx
  namespace: ingress-nginx
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-admission
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: ingress-nginx-admission
subjects:
- kind: ServiceAccount
  name: ingress-nginx-admission
  namespace: ingress-nginx
---
# ============================================================================
# CONFIGMAP - NGINX Controller Configuration
# ============================================================================
# This ConfigMap contains configuration options for NGINX
# The controller reads this and generates the actual NGINX config file
# You can add options like:
#   proxy-body-size: "50m"  # Max request body size
#   proxy-connect-timeout: "10"  # Upstream connection timeout
#   use-gzip: "true"  # Enable gzip compression
#   ssl-protocols: "TLSv1.2 TLSv1.3"  # Allowed TLS versions
# ============================================================================
apiVersion: v1
data:
  allow-snippet-annotations: "true"  # Allow custom NGINX snippets in Ingress annotations (security risk in prod)
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-controller  # Referenced by Deployment (--configmap flag)
  namespace: ingress-nginx
---
# ============================================================================
# SERVICE - Expose NGINX Controller
# ============================================================================
# This Service exposes the NGINX controller pods on ports 80 (HTTP) and 443 (HTTPS)
# Type: NodePort - For local/kind clusters, exposes on node ports
#       LoadBalancer - For cloud (EKS/GKE/AKS), creates cloud load balancer
# The kind-config.yaml maps these to localhost:80 and localhost:443
# ============================================================================
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-controller  # Service name (used by admission webhook)
  namespace: ingress-nginx
spec:
  ipFamilies:
  - IPv4  # Use IPv4 addresses
  ipFamilyPolicy: SingleStack  # IPv4 only (could be DualStack for IPv4+IPv6)
  ports:
  - appProtocol: http  # Application protocol (informational)
    name: http  # Port name
    port: 80  # External port (what clients connect to)
    protocol: TCP
    targetPort: http  # Target port on controller pod (named port from Deployment)
  - appProtocol: https
    name: https
    port: 443  # HTTPS port
    protocol: TCP
    targetPort: https  # Target port on controller pod
  selector:  # Route traffic to pods with these labels (from Deployment)
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  type: NodePort  # For local: NodePort, For cloud: LoadBalancer
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-controller-admission
  namespace: ingress-nginx
spec:
  ports:
  - appProtocol: https
    name: https-webhook
    port: 443
    targetPort: webhook
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  type: ClusterIP
---
# ============================================================================
# DEPLOYMENT - The actual NGINX Ingress Controller pods
# ============================================================================
# This is the heart of the ingress controller - the pods that run NGINX
# and watch for Ingress resources to configure routing
# ============================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-controller  # Deployment name
  namespace: ingress-nginx
spec:
  minReadySeconds: 0  # Pod ready immediately after health checks pass
  revisionHistoryLimit: 10  # Keep 10 old ReplicaSets for rollback
  selector:
    matchLabels:  # Pods this Deployment manages
      app.kubernetes.io/component: controller
      app.kubernetes.io/instance: ingress-nginx
      app.kubernetes.io/name: ingress-nginx
  strategy:
    rollingUpdate:
      maxUnavailable: 1  # Max 1 pod down during updates
    type: RollingUpdate  # Update pods gradually
  template:
    metadata:
      labels:  # Labels applied to pods (must match selector above)
        app.kubernetes.io/component: controller
        app.kubernetes.io/instance: ingress-nginx
        app.kubernetes.io/name: ingress-nginx
        app.kubernetes.io/part-of: ingress-nginx
        app.kubernetes.io/version: 1.8.1
    spec:
      containers:
      - args:  # Command-line arguments for the controller
        - /nginx-ingress-controller  # Controller binary
        - --election-id=ingress-nginx-leader  # Leader election for HA
        - --controller-class=k8s.io/ingress-nginx  # Controller identifier
        - --ingress-class=nginx  # Watch for ingressClassName: nginx
        - --configmap=$(POD_NAMESPACE)/ingress-nginx-controller  # ConfigMap for NGINX config
        - --validating-webhook=:8443  # Admission webhook port
        - --validating-webhook-certificate=/usr/local/certificates/cert  # Webhook cert
        - --validating-webhook-key=/usr/local/certificates/key  # Webhook key
        - --watch-ingress-without-class=true  # Watch Ingress resources without ingressClassName
        - --publish-status-address=localhost  # Address to publish in Ingress status
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: LD_PRELOAD
          value: /usr/local/lib/libmimalloc.so
        image: registry.k8s.io/ingress-nginx/controller:v1.8.1@sha256:e5c4824e7375fcf2a393e1c03c293b69759af37a9ca6abdb91b13d78a93da8bd
        imagePullPolicy: IfNotPresent
        lifecycle:
          preStop:
            exec:
              command:
              - /wait-shutdown
        livenessProbe:
          failureThreshold: 5
          httpGet:
            path: /healthz
            port: 10254
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        name: controller
        ports:
        - containerPort: 80
          hostPort: 80
          name: http
          protocol: TCP
        - containerPort: 443
          hostPort: 443
          name: https
          protocol: TCP
        - containerPort: 8443
          name: webhook
          protocol: TCP
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /healthz
            port: 10254
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        resources:
          requests:
            cpu: 100m
            memory: 90Mi
        securityContext:
          allowPrivilegeEscalation: true
          capabilities:
            add:
            - NET_BIND_SERVICE
            drop:
            - ALL
          runAsUser: 101
        volumeMounts:
        - mountPath: /usr/local/certificates/
          name: webhook-cert
          readOnly: true
      dnsPolicy: ClusterFirst
      nodeSelector:
        ingress-ready: "true"
        kubernetes.io/os: linux
      serviceAccountName: ingress-nginx
      terminationGracePeriodSeconds: 0
      tolerations:
      - effect: NoSchedule
        key: node-role.kubernetes.io/master
        operator: Equal
      - effect: NoSchedule
        key: node-role.kubernetes.io/control-plane
        operator: Equal
      volumes:
      - name: webhook-cert
        secret:
          secretName: ingress-nginx-admission
---
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-admission-create
  namespace: ingress-nginx
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/component: admission-webhook
        app.kubernetes.io/instance: ingress-nginx
        app.kubernetes.io/name: ingress-nginx
        app.kubernetes.io/part-of: ingress-nginx
        app.kubernetes.io/version: 1.8.1
      name: ingress-nginx-admission-create
    spec:
      containers:
      - args:
        - create
        - --host=ingress-nginx-controller-admission,ingress-nginx-controller-admission.$(POD_NAMESPACE).svc
        - --namespace=$(POD_NAMESPACE)
        - --secret-name=ingress-nginx-admission
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        image: registry.k8s.io/ingress-nginx/kube-webhook-certgen:v20230407@sha256:543c40fd093964bc9ab509d3e791f9989963021f1e9e4c9c7b6700b02bfb227b
        imagePullPolicy: IfNotPresent
        name: create
        securityContext:
          allowPrivilegeEscalation: false
      nodeSelector:
        kubernetes.io/os: linux
      restartPolicy: OnFailure
      securityContext:
        fsGroup: 2000
        runAsNonRoot: true
        runAsUser: 2000
      serviceAccountName: ingress-nginx-admission
---
apiVersion: batch/v1
kind: Job
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-admission-patch
  namespace: ingress-nginx
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/component: admission-webhook
        app.kubernetes.io/instance: ingress-nginx
        app.kubernetes.io/name: ingress-nginx
        app.kubernetes.io/part-of: ingress-nginx
        app.kubernetes.io/version: 1.8.1
      name: ingress-nginx-admission-patch
    spec:
      containers:
      - args:
        - patch
        - --webhook-name=ingress-nginx-admission
        - --namespace=$(POD_NAMESPACE)
        - --patch-mutating=false
        - --secret-name=ingress-nginx-admission
        - --patch-failure-policy=Fail
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        image: registry.k8s.io/ingress-nginx/kube-webhook-certgen:v20230407@sha256:543c40fd093964bc9ab509d3e791f9989963021f1e9e4c9c7b6700b02bfb227b
        imagePullPolicy: IfNotPresent
        name: patch
        securityContext:
          allowPrivilegeEscalation: false
      nodeSelector:
        kubernetes.io/os: linux
      restartPolicy: OnFailure
      securityContext:
        fsGroup: 2000
        runAsNonRoot: true
        runAsUser: 2000
      serviceAccountName: ingress-nginx-admission
---
# ============================================================================
# INGRESSCLASS - Critical: Links ingress.yaml to this controller
# ============================================================================
# This is THE KEY resource that connects everything together!
#
# When you create ingress.yaml with:
#   spec:
#     ingressClassName: nginx  ← References this IngressClass by name
#
# The NGINX controller looks for Ingress resources that reference this class
# and configures routing for them. Without this, your ingress.yaml won't work!
#
# Other ingress controllers (Traefik, ALB) would have their own IngressClass
# with different controller identifiers.
# ============================================================================
apiVersion: networking.k8s.io/v1
kind: IngressClass  # Defines an ingress controller class
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: nginx  # ← This name is what ingress.yaml references with ingressClassName: nginx
spec:
  controller: k8s.io/ingress-nginx  # Controller identifier (matches --controller-class in Deployment)
---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  labels:
    app.kubernetes.io/component: admission-webhook
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.8.1
  name: ingress-nginx-admission
webhooks:
- admissionReviewVersions:
  - v1
  clientConfig:
    service:
      name: ingress-nginx-controller-admission
      namespace: ingress-nginx
      path: /networking/v1/ingresses
  failurePolicy: Fail
  matchPolicy: Equivalent
  name: validate.nginx.ingress.kubernetes.io
  rules:
  - apiGroups:
    - networking.k8s.io
    apiVersions:
    - v1
    operations:
    - CREATE
    - UPDATE
    resources:
    - ingresses
  sideEffects: None


----- filename : ingress.yaml -----
apiVersion: networking.k8s.io/v1  # Kubernetes API version for Ingress resources
kind: Ingress  # Type of resource - routes external HTTP/HTTPS traffic to services
metadata:  # Information about this Ingress
  name: health-service-ingress  # Name of this Ingress rule
  # namespace: default  # Optional: Namespace (defaults to 'default')
  labels:  # Labels for organizing
    app: health-service  # Identifies this as part of health-service app
  # annotations:  # Optional: Controller-specific configuration
  #   # NGINX Ingress annotations:
  #   nginx.ingress.kubernetes.io/rewrite-target: /  # Rewrite URL path
  #   nginx.ingress.kubernetes.io/ssl-redirect: "true"  # Force HTTPS
  #   nginx.ingress.kubernetes.io/rate-limit: "100"  # Rate limiting
  #   nginx.ingress.kubernetes.io/cors-allow-origin: "*"  # CORS headers
  #   # AWS ALB Ingress annotations:
  #   # alb.ingress.kubernetes.io/scheme: internet-facing  # Public or internal
  #   # alb.ingress.kubernetes.io/target-type: ip  # ip or instance
  #   # alb.ingress.kubernetes.io/healthcheck-path: /health
  #   # cert-manager annotation for automatic TLS:
  #   # cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:  # Ingress specification
  ingressClassName: nginx  # Which Ingress controller handles this (nginx, alb, traefik, etc.)
  # defaultBackend:  # Optional: Default backend if no rules match
  #   service:
  #     name: default-backend
  #     port:
  #       number: 80
  # tls:  # Optional: TLS/HTTPS configuration
  # - hosts:  # Domains for this certificate
  #   - api.example.com
  #   - www.example.com
  #   secretName: tls-secret  # Secret containing TLS cert and key
  rules:  # Routing rules for incoming traffic
  # Example: Host-based routing (different domains)
  # - host: api.example.com  # Match this domain
  #   http:
  #     paths:
  #     - path: /
  #       pathType: Prefix
  #       backend:
  #         service:
  #           name: api-service
  #           port:
  #             number: 80
  # - host: app.example.com  # Different domain
  #   http:
  #     paths:
  #     - path: /
  #       pathType: Prefix
  #       backend:
  #         service:
  #           name: app-service
  #           port:
  #             number: 80
  - http:  # HTTP traffic rules (no host = match all domains)
      paths:  # URL path-based routing
      - path: /  # Path to match (/ = all paths, /api = only /api/*)
        pathType: Prefix  # Match type: Prefix (starts with), Exact (exact match), or ImplementationSpecific
        backend:  # Where to send matching traffic
          service:  # Route to a Kubernetes Service
            name: health-service  # Service name (from service-clusterip.yaml)
            port:  # Which port on the Service
              number: 80  # Service port (matches service.spec.ports[].port)
              # name: http  # Alternative: use port name instead of number
      # Example: Path-based routing (different paths to different services)
      # - path: /api
      #   pathType: Prefix
      #   backend:
      #     service:
      #       name: api-service
      #       port:
      #         number: 80
      # - path: /auth
      #   pathType: Prefix
      #   backend:
      #     service:
      #       name: auth-service
      #       port:
      #         number: 80

# Common patterns:
# 1. Single service (what you have): All traffic to one service
# 2. Path-based routing: /api -> api-service, /auth -> auth-service
# 3. Host-based routing: api.example.com -> api-service, www.example.com -> web-service
# 4. HTTPS with cert-manager: Add tls section + cert-manager annotation


----- filename : service-clusterip.yaml -----
apiVersion: v1  # Kubernetes API version for Services (core/stable)
kind: Service  # Type of resource - provides stable network endpoint for pods
metadata:  # Information about this Service
  name: health-service  # Service name (used as DNS name: health-service.default.svc.cluster.local) → MUST MATCH ingress.yaml backend service name (line 60)
  # namespace: default  # Optional: Namespace (defaults to 'default')
  labels:  # Labels for organizing this Service
    app: health-service  # Identifies this as part of health-service app (not used for matching, just organization)
  # annotations:  # Optional: Service annotations
  #   service.beta.kubernetes.io/aws-load-balancer-type: "nlb"  # For LoadBalancer: use NLB
  #   service.beta.kubernetes.io/aws-load-balancer-internal: "true"  # Internal LB
  #   prometheus.io/scrape: "true"  # Prometheus annotations
  #   prometheus.io/port: "8080"
spec:  # Service specification
  type: ClusterIP  # Service type: ClusterIP (internal only), LoadBalancer (external), NodePort (node ports)
  # clusterIP: None  # Optional: "None" for headless service (no load balancing, direct pod IPs)
  # sessionAffinity: None  # Optional: None (default) or ClientIP (sticky sessions)
  # sessionAffinityConfig:  # Optional: Configure session affinity
  #   clientIP:
  #     timeoutSeconds: 10800  # Session timeout (default: 10800 = 3 hours)
  # externalTrafficPolicy: Cluster  # Optional: Cluster (default) or Local (preserves source IP)
  # publishNotReadyAddresses: false  # Optional: Include not-ready pods in endpoints
  selector:  # Which pods this Service routes traffic to
    app: health-service  # → MUST MATCH deployment.yaml template.metadata.labels.app (line 28)
  ports:  # Port mappings
  - port: 80  # Port the Service listens on (what other services/ingress connect to) → MUST MATCH ingress.yaml backend port (line 62)
    targetPort: 8080  # Port on the pod/container (where your app actually listens) → MUST MATCH deployment.yaml containerPort (line 92)
    protocol: TCP  # Network protocol (TCP or UDP)
    name: http  # Name for this port (useful when multiple ports defined) - not used for matching
    # nodePort: 30080  # Optional: For NodePort/LoadBalancer type, specify node port (30000-32767)
    # appProtocol: http  # Optional: Application protocol (http, https, grpc)
  # Optional: Additional ports
  # - port: 443
  #   targetPort: 8443
  #   protocol: TCP
  #   name: https
  # Optional: External IPs (route external traffic to service)
  # externalIPs:
  # - 80.11.12.10
  # Optional: LoadBalancer specific settings
  # loadBalancerIP: 78.11.24.19  # Request specific IP (cloud provider dependent)
  # loadBalancerSourceRanges:  # Restrict access to these CIDR blocks
  # - 10.0.0.0/8
  # - 192.168.0.0/16
  # externalName: my.database.example.com  # For ExternalName type only


